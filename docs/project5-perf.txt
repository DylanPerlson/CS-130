Performance Log
================


IGNORE ALL THE STUFF BELOW, THAT IS FROM P3

-- tarjan was slow bc running it 
-- get cell reference was alot slower
-- doing things recursively, not a speed increase but it did stop python from breaking, so scaling performance increase


Tarjan redundancy
---------------

**Theory**
We expect that there was an uneccesarrily high amount of Tarjan algorithm calls to find circular references. Because the tarjan algorithm iterates through every single cell in the workbook, it is a very time intensive algorithm. Before implementing any changes, we would call the tarjan algorithm every single time we called set_cell_contents(). So if we wanted to get the value of a single cell after moving 1000 cells, we would have to call tarjan 1000 times. We suspect if we move the tarjan algorithm to get_cell_value() instead, we would see massive speed increases because it would be called significantly less when setting large amounts of cells.

**Rationale**
As we can see in the below cProfiler data, the helper function for our tarjan algorithm is taking up a vast majority of the time for our performance test. This supports our hypothesis that the tarjan function is taking up a significant amount of time due to redundancies.

17738176 function calls (17700214 primitive calls) in 14.297 seconds

   Ordered by: internal time
   List reduced from 113 to 5 due to restriction <5>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   499500    6.112    0.000    8.486    0.000 c:\Users\Dylan\Documents\GitHub\CS-130\sheets\workbook.py:1092(_tarjan_helper)
   498501    1.997    0.000    1.997    0.000 {method 'index' of 'list' objects}
     7884    1.286    0.000    3.831    0.000 C:\Users\Dylan\anaconda3\lib\site-packages\lark\parsers\earley.py:65(predict_and_complete)
      999    0.902    0.001    9.389    0.009 c:\Users\Dylan\Documents\GitHub\CS-130\sheets\workbook.py:1153(_tarjan) 
   938061    0.768    0.000    1.161    0.000 

**Outcome**
After we made changes to the tarjan function, we can see a massive increase in our performance test speed. Our previous test took 14.3 seconds to complete, and now it takes 5.2 seconds to compelte. This is an almost 3x speed improvement. Additionally, we can see from the cProfiler data below, that the Tarjan algorithm functions are no longer taking the majority of the time because they are being called significantly less.

13507542 function calls (13453596 primitive calls) in 5.187 seconds

   Ordered by: cumulative time
   List reduced from 135 to 10 due to restriction <10>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     1000    0.009    0.000    5.160    0.005 c:\Users\Dylan\Documents\GitHub\CS-130\sheets\workbook.py:549(set_cell_contents)
4998/3000    0.008    0.000    5.093    0.002 c:\Users\Dylan\Documents\GitHub\CS-130\sheets\sheet.py:99(get_cell_value)
4997/3000    0.021    0.000    5.080    0.002 


Getting the Cell Value
----------------------

